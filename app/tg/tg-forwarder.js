import plugin from '../../../../lib/plugins/plugin.js';
import fetch from 'node-fetch';
import fs from 'node:fs';
import path from 'node:path';
import common from '../../../../lib/common/common.js';
import { fileURLToPath } from 'url';
import { HttpsProxyAgent } from 'https-proxy-agent';
import setting from '../../model/tg/tg-setting.js';

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);
const pluginRoot = path.resolve(process.cwd(), 'plugins', 'yunzai-plugin-integration');
const tempDir = path.join(pluginRoot, 'temp', 'tg');

export class TgForwarder extends plugin {
  constructor() {
    super({
      name: '[TGÊèí‰ª∂] TelegramÊ∂àÊÅØËΩ¨Âèë',
      dsc: 'ÁõëÊéßTelegramÈ¢ëÈÅìÂπ∂ËΩ¨ÂèëÂà∞QQÁæ§',
      event: 'message',
      priority: 500,
      rule: [
        { reg: '^#ÊãâÂèñtg$', fnc: 'manualFetch' },
        { reg: '^#tgÁä∂ÊÄÅ$', fnc: 'getStatus' },
        { reg: '^#ÂÅúÊ≠¢tg$', fnc: 'stopMonitoring' }
      ]
    });
    
    this.monitorInterval = null;
    this.isRunning = false;
    this.lastUpdateId = this.loadLastUpdateId();
    
    // Á°Æ‰øù‰∏¥Êó∂ÁõÆÂΩïÂ≠òÂú®
    this.ensureTempDir();
    
    // ÂêØÂä®Êó∂Ëá™Âä®ÂºÄÂßãÁõëÊéß
    this.startMonitoring();
  }

  async manualFetch(e) {
    if (!e.isMaster) return e.reply('‚ùå ÊùÉÈôê‰∏çË∂≥Ôºå‰ªÖ‰∏ª‰∫∫ÂèØÊìç‰Ωú');
    
    await e.reply('üîÑ ÂºÄÂßãÊâãÂä®ÊãâÂèñTGÊ∂àÊÅØ...');
    
    try {
      const result = await this.fetchAndForward();
      if (result.count > 0) {
        await e.reply(`‚úÖ ÊàêÂäüËΩ¨Âèë ${result.count} Êù°Ê∂àÊÅØ`);
      } else {
        await e.reply('üí° ÊöÇÊó†Êñ∞Ê∂àÊÅØ');
      }
      
      // ÈáçÊñ∞ÂºÄÂßãÂÆöÊó∂ÁõëÊéß
      this.restartMonitoring();
      
    } catch (error) {
      logger.error('[TGËΩ¨Âèë] ÊâãÂä®ÊãâÂèñÂ§±Ë¥•:', error);
      await e.reply(`‚ùå ÊãâÂèñÂ§±Ë¥•: ${error.message}`);
    }
    
    return true;
  }

  async getStatus(e) {
    if (!e.isMaster) return e.reply('‚ùå ÊùÉÈôê‰∏çË∂≥');
    
    const config = setting.getConfig('tg-forwarder');
    const status = this.isRunning ? 'üü¢ ËøêË°å‰∏≠' : 'üî¥ Â∑≤ÂÅúÊ≠¢';
    const nextCheck = this.monitorInterval ? 
      new Date(Date.now() + config.monitor.interval).toLocaleString() : 'Êú™ËÆæÁΩÆ';
    
    const statusMsg = [
      'üìä TGËΩ¨ÂèëÁä∂ÊÄÅ',
      `Áä∂ÊÄÅ: ${status}`,
      `ÁõëÊéßÈ¢ëÈÅì: ${config.telegram.channels.join(', ')}`,
      `ÁõÆÊ†áÁæ§: ${config.qq.targetGroups.join(', ')}`,
      `Ê£ÄÊü•Èó¥Èöî: ${config.monitor.interval / 1000}Áßí`,
      `‰∏ãÊ¨°Ê£ÄÊü•: ${nextCheck}`,
      `‰∏äÊ¨°Ê∂àÊÅØID: ${this.lastUpdateId || 'Êó†'}`
    ].join('\n');
    
    return e.reply(statusMsg);
  }

  async stopMonitoring(e) {
    if (!e.isMaster) return e.reply('‚ùå ÊùÉÈôê‰∏çË∂≥');
    
    if (this.monitorInterval) {
      clearInterval(this.monitorInterval);
      this.monitorInterval = null;
      this.isRunning = false;
      return e.reply('‚èπÔ∏è TGÁõëÊéßÂ∑≤ÂÅúÊ≠¢');
    } else {
      return e.reply('üí° ÁõëÊéßÊú™ËøêË°å');
    }
  }

  startMonitoring() {
    const config = setting.getConfig('tg-forwarder');
    
    if (!config.monitor.enabled) {
      logger.info('[TGËΩ¨Âèë] ÁõëÊéßÂäüËÉΩÂ∑≤Á¶ÅÁî®');
      return;
    }
    
    if (this.monitorInterval) {
      clearInterval(this.monitorInterval);
    }
    
    this.monitorInterval = setInterval(async () => {
      try {
        await this.fetchAndForward();
      } catch (error) {
        logger.error('[TGËΩ¨Âèë] ÂÆöÊó∂ÁõëÊéßÂ§±Ë¥•:', error);
      }
    }, config.monitor.interval);
    
    this.isRunning = true;
    logger.info(`[TGËΩ¨Âèë] Â∑≤ÂêØÂä®ÁõëÊéßÔºåÈó¥Èöî ${config.monitor.interval / 1000} Áßí`);
  }

  restartMonitoring() {
    if (this.monitorInterval) {
      clearInterval(this.monitorInterval);
    }
    this.startMonitoring();
  }

  async fetchAndForward() {
    const config = setting.getConfig('tg-forwarder');
    let totalCount = 0;
    
    for (const channel of config.telegram.channels) {
      try {
        const updates = await this.getTelegramUpdates(channel);
        
        if (updates.length === 0) continue;
        
        const messages = await this.processMessages(updates);
        
        if (messages.length > 0) {
          await this.forwardToQQGroups(messages);
          totalCount += messages.length;
          
          // Êõ¥Êñ∞ÊúÄÂêéÂ§ÑÁêÜÁöÑÊ∂àÊÅØID
          const lastUpdate = updates[updates.length - 1];
          this.saveLastUpdateId(lastUpdate.update_id);
          
          logger.info(`[TGËΩ¨Âèë] ‰ªéÈ¢ëÈÅì ${channel} ËΩ¨Âèë‰∫Ü ${messages.length} Êù°Ê∂àÊÅØ`);
        }
        
      } catch (error) {
        logger.error(`[TGËΩ¨Âèë] Â§ÑÁêÜÈ¢ëÈÅì ${channel} Â§±Ë¥•:`, error);
      }
    }
    
    return { count: totalCount };
  }

  async getTelegramUpdates(channel) {
    const config = setting.getConfig('tg-forwarder');
    const botToken = config.telegram.botToken;
    
    if (!botToken) {
      throw new Error('Êú™ÈÖçÁΩÆBot Token');
    }
    
    const url = `https://api.telegram.org/bot${botToken}/getUpdates`;
    const params = new URLSearchParams({
      offset: this.lastUpdateId + 1,
      limit: 100,
      allowed_updates: JSON.stringify(['channel_post'])
    });
    
    const fetchOptions = {
      method: 'GET',
      timeout: 30000
    };
    
    // Ê∑ªÂä†‰ª£ÁêÜÊîØÊåÅ
    if (config.proxy.enabled && config.proxy.url) {
      fetchOptions.agent = new HttpsProxyAgent(config.proxy.url);
      logger.debug(`[TGËΩ¨Âèë] ‰ΩøÁî®‰ª£ÁêÜ: ${config.proxy.url}`);
    }
    
    const response = await fetch(`${url}?${params}`, fetchOptions);
    
    if (!response.ok) {
      throw new Error(`Telegram API ËØ∑Ê±ÇÂ§±Ë¥•: ${response.status} ${response.statusText}`);
    }
    
    const data = await response.json();
    
    if (!data.ok) {
      throw new Error(`Telegram API ÈîôËØØ: ${data.description || 'Êú™Áü•ÈîôËØØ'}`);
    }
    
    // ËøáÊª§ÊåáÂÆöÈ¢ëÈÅìÁöÑÊ∂àÊÅØ
    const channelUsername = channel.replace('@', '');
    return data.result.filter(update => 
      update.channel_post?.chat?.username === channelUsername
    );
  }

  async processMessages(updates) {
    const messages = [];
    
    for (const update of updates) {
      try {
        const post = update.channel_post;
        const messageContent = [];
        
        // Â§ÑÁêÜÊñáÊú¨
        if (post.text || post.caption) {
          const text = post.text || post.caption || '';
          if (text.trim()) {
            messageContent.push(text);
          }
        }
        
        // Â§ÑÁêÜÂõæÁâá
        if (post.photo && post.photo.length > 0) {
          const photo = post.photo[post.photo.length - 1]; // ÊúÄÈ´òË¥®Èáè
          if (photo.file_size <= 50 * 1024 * 1024) { // 50MBÈôêÂà∂
            const imagePath = await this.downloadMedia(photo.file_id, 'photo');
            if (imagePath) {
              messageContent.push(segment.image(imagePath));
            }
          }
        }
        
        // Â§ÑÁêÜËßÜÈ¢ë
        if (post.video) {
          if (post.video.file_size <= 50 * 1024 * 1024) { // 50MBÈôêÂà∂
            const videoPath = await this.downloadMedia(post.video.file_id, 'video');
            if (videoPath) {
              messageContent.push(segment.video(videoPath));
            }
          } else {
            logger.info(`[TGËΩ¨Âèë] ËßÜÈ¢ëÊñá‰ª∂ËøáÂ§ß (${post.video.file_size}B)ÔºåË∑≥ËøáÂ§ÑÁêÜ`);
          }
        }
        
        // Â§ÑÁêÜÊñáÊ°£
        if (post.document && post.document.file_size <= 50 * 1024 * 1024) {
          const docPath = await this.downloadMedia(post.document.file_id, 'document');
          if (docPath) {
            const fileName = post.document.file_name || `document_${Date.now()}`;
            messageContent.push(`üìÑ ÊñáÊ°£: ${fileName}`);
            // Ê≥®ÊÑèÔºöQQÂèØËÉΩ‰∏çÊîØÊåÅÁõ¥Êé•ÂèëÈÄÅÊñáÊ°£ÔºåËøôÈáåÂè™ÊòØÁ§∫‰æã
          }
        }
        
        if (messageContent.length > 0) {
          messages.push({
            content: messageContent,
            date: new Date(post.date * 1000),
            messageId: post.message_id,
            channelTitle: post.chat.title || post.chat.username
          });
        }
        
      } catch (error) {
        logger.error('[TGËΩ¨Âèë] Â§ÑÁêÜÂçïÊù°Ê∂àÊÅØÂ§±Ë¥•:', error);
      }
    }
    
    return messages;
  }

  async downloadMedia(fileId, type) {
    try {
      const fileUrl = await this.getFileUrl(fileId);
      if (!fileUrl) return null;
      
      const config = setting.getConfig('tg-forwarder');
      const fetchOptions = { timeout: 60000 };
      
      if (config.proxy.enabled && config.proxy.url) {
        fetchOptions.agent = new HttpsProxyAgent(config.proxy.url);
      }
      
      const response = await fetch(fileUrl, fetchOptions);
      
      if (!response.ok) {
        throw new Error(`‰∏ãËΩΩÂ§±Ë¥•: ${response.status}`);
      }
      
      const buffer = await response.buffer();
      const fileName = `${type}_${Date.now()}_${Math.random().toString(36).substr(2, 9)}.${this.getFileExtension(type)}`;
      const filePath = path.join(tempDir, fileName);
      
      fs.writeFileSync(filePath, buffer);
      return filePath;
      
    } catch (error) {
      logger.error(`[TGËΩ¨Âèë] ‰∏ãËΩΩÂ™í‰ΩìÂ§±Ë¥• (${type}):`, error);
      return null;
    }
  }

  async getFileUrl(fileId) {
    try {
      const config = setting.getConfig('tg-forwarder');
      const botToken = config.telegram.botToken;
      
      const url = `https://api.telegram.org/bot${botToken}/getFile?file_id=${fileId}`;
      const fetchOptions = { timeout: 10000 };
      
      if (config.proxy.enabled && config.proxy.url) {
        fetchOptions.agent = new HttpsProxyAgent(config.proxy.url);
      }
      
      const response = await fetch(url, fetchOptions);
      const data = await response.json();
      
      if (data.ok && data.result.file_path) {
        return `https://api.telegram.org/file/bot${botToken}/${data.result.file_path}`;
      }
      
      return null;
    } catch (error) {
      logger.error('[TGËΩ¨Âèë] Ëé∑ÂèñÊñá‰ª∂URLÂ§±Ë¥•:', error);
      return null;
    }
  }

  async forwardToQQGroups(messages) {
    const config = setting.getConfig('tg-forwarder');
    
    if (messages.length === 0) return;
    
    // ÊûÑÂª∫ÂêàÂπ∂ËΩ¨ÂèëÊ∂àÊÅØ
    const forwardMsgs = messages.map(msg => ({
      message: Array.isArray(msg.content) ? msg.content : [msg.content],
      nickname: `üì° ${msg.channelTitle || 'TGÈ¢ëÈÅì'}`,
      user_id: Bot.uin
    }));
    
    try {
      const forwardMsg = await Bot.makeForwardMsg(forwardMsgs);
      
      for (const groupId of config.qq.targetGroups) {
        try {
          await Bot.sendGroupMsg(groupId, forwardMsg);
          logger.info(`[TGËΩ¨Âèë] ÊàêÂäüËΩ¨ÂèëÂà∞Áæ§ ${groupId}`);
          
          // Á≠âÂæÖ‰∏Ä‰∏ãÈÅøÂÖçÂèëÈÄÅËøáÂø´
          await new Promise(resolve => setTimeout(resolve, 1000));
          
        } catch (error) {
          logger.error(`[TGËΩ¨Âèë] ÂèëÈÄÅÂà∞Áæ§ ${groupId} Â§±Ë¥•:`, error);
        }
      }
      
    } catch (error) {
      logger.error('[TGËΩ¨Âèë] ÂàõÂª∫ÂêàÂπ∂ËΩ¨ÂèëÊ∂àÊÅØÂ§±Ë¥•:', error);
    }
    
    // ËΩ¨ÂèëÂÆåÊàêÂêéÊ∏ÖÁêÜÊñá‰ª∂
    await this.cleanupFiles(messages);
  }

  async cleanupFiles(messages) {
    for (const msg of messages) {
      if (Array.isArray(msg.content)) {
        for (const item of msg.content) {
          if (typeof item === 'object' && item.file) {
            try {
              if (fs.existsSync(item.file)) {
                fs.unlinkSync(item.file);
                logger.debug(`[TGËΩ¨Âèë] Ê∏ÖÁêÜÊñá‰ª∂: ${item.file}`);
              }
            } catch (error) {
              logger.warn(`[TGËΩ¨Âèë] Ê∏ÖÁêÜÊñá‰ª∂Â§±Ë¥•: ${error.message}`);
            }
          }
        }
      }
    }
  }

  getFileExtension(type) {
    const extensions = {
      photo: 'jpg',
      video: 'mp4',
      document: 'bin',
      audio: 'mp3'
    };
    return extensions[type] || 'bin';
  }

  loadLastUpdateId() {
    const dataFile = path.join(pluginRoot, 'data', 'tg-last-update.json');
    
    try {
      if (fs.existsSync(dataFile)) {
        const data = JSON.parse(fs.readFileSync(dataFile, 'utf8'));
        return data.lastUpdateId || 0;
      }
    } catch (error) {
      logger.warn('[TGËΩ¨Âèë] ËØªÂèñ‰∏äÊ¨°Êõ¥Êñ∞IDÂ§±Ë¥•:', error);
    }
    
    return 0;
  }

  saveLastUpdateId(updateId) {
    const dataDir = path.join(pluginRoot, 'data');
    const dataFile = path.join(dataDir, 'tg-last-update.json');
    
    try {
      if (!fs.existsSync(dataDir)) {
        fs.mkdirSync(dataDir, { recursive: true });
      }
      
      const data = { 
        lastUpdateId: updateId, 
        lastUpdate: new Date().toISOString() 
      };
      
      fs.writeFileSync(dataFile, JSON.stringify(data, null, 2));
      this.lastUpdateId = updateId;
      
    } catch (error) {
      logger.error('[TGËΩ¨Âèë] ‰øùÂ≠òÊõ¥Êñ∞IDÂ§±Ë¥•:', error);
    }
  }

  ensureTempDir() {
    try {
      if (!fs.existsSync(tempDir)) {
        fs.mkdirSync(tempDir, { recursive: true });
        logger.info(`[TGËΩ¨Âèë] ÂàõÂª∫‰∏¥Êó∂ÁõÆÂΩï: ${tempDir}`);
      }
    } catch (error) {
      logger.error('[TGËΩ¨Âèë] ÂàõÂª∫‰∏¥Êó∂ÁõÆÂΩïÂ§±Ë¥•:', error);
    }
  }

  // Êèí‰ª∂ÈîÄÊØÅÊó∂Ê∏ÖÁêÜ
  destroy() {
    if (this.monitorInterval) {
      clearInterval(this.monitorInterval);
      this.monitorInterval = null;
    }
    this.isRunning = false;
    logger.info('[TGËΩ¨Âèë] Êèí‰ª∂Â∑≤ÂÅúÊ≠¢');
  }
}